/* -LICENSE-START-
** Copyright (c) 2013 Blackmagic Design
**  
** Permission is hereby granted, free of charge, to any person or organization 
** obtaining a copy of the software and accompanying documentation (the 
** "Software") to use, reproduce, display, distribute, sub-license, execute, 
** and transmit the Software, and to prepare derivative works of the Software, 
** and to permit third-parties to whom the Software is furnished to do so, in 
** accordance with:
** 
** (1) if the Software is obtained from Blackmagic Design, the End User License 
** Agreement for the Software Development Kit (“EULA”) available at 
** https://www.blackmagicdesign.com/EULA/DeckLinkSDK; or
** 
** (2) if the Software is obtained from any third party, such licensing terms 
** as notified by that third party,
** 
** and all subject to the following:
** 
** (3) the copyright notices in the Software and this entire statement, 
** including the above license grant, this restriction and the following 
** disclaimer, must be included in all copies of the Software, in whole or in 
** part, and all derivative works of the Software, unless such copies or 
** derivative works are solely in the form of machine-executable object code 
** generated by a source language processor.
** 
** (4) THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
** OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT 
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, 
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
** DEALINGS IN THE SOFTWARE.
** 
** A copy of the Software is available free of charge at 
** https://www.blackmagicdesign.com/desktopvideo_sdk under the EULA.
** 
** -LICENSE-END-
*/
/* -LICENSE-ADDITIONAL-
** This file is based on the "Capture.cpp" file from the Blackmagic API, and changes are provided as is 
** -LICENSE-END-
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>
#include <fcntl.h>
#include <csignal>
#include <math.h>
#include <time.h>

#include "DeckLinkAPI.h"
#include "BLT.h"
#include "Config.h"

static pthread_mutex_t    g_sleepMutex;
static pthread_cond_t    g_sleepCond;
static int                g_videoOutputFile = -1;
static int                g_audioOutputFile = -1;
static bool                g_do_exit = false;

static BMDConfig        g_config;

static IDeckLinkInput*    g_deckLinkInput = NULL;
static IDeckLinkOutput*   g_deckLinkOutput = NULL;


static signed int     DEBUG = 0; 
static signed long    g_lastDecodeTime = 0;
static signed int     g_lastDecodeTimeFrames = 0;
static signed long    g_lastRealTime = 0;
static signed int     g_lastRealTimeFrames = 0;
static unsigned int     g_currentLatency = 0;
static signed int     g_frameCalibration = 6; // number of frames the entire process takes for a Blackmagic->Blackmagic plugged directly together

static unsigned long    g_video_frameCount = 0;
static unsigned long    g_lastSilenceStart = -10;
static unsigned long    g_lastSilenceEnd = -10;
static unsigned long    g_lastSilenceStartSample = -10;

static unsigned long    g_lastAudioSilenceStart = -10;
static unsigned long    g_lastAudioSilenceEnd = -10;
static unsigned long    g_silentSamples = 0;
static signed long    g_audioDelay = 0;


static unsigned long    g_dumpEvery = -1;
static unsigned long    g_lastFlash = 0;
static unsigned long    g_currentFlash = 0;
static unsigned long    g_ch1Silent = 0;
static unsigned long    g_audio_frameCount = 0;

DeckLinkBLTDelegate::DeckLinkBLTDelegate() : 
    m_refCount(1),
    m_pixelFormat(g_config.m_pixelFormat)
{
}

ULONG DeckLinkBLTDelegate::AddRef(void)
{
    return __sync_add_and_fetch(&m_refCount, 1);
}

ULONG DeckLinkBLTDelegate::Release(void)
{
    int32_t newRefValue = __sync_sub_and_fetch(&m_refCount, 1);
    if (newRefValue == 0)
    {
        delete this;
        return 0;
    }
    return newRefValue;
}

HRESULT DeckLinkBLTDelegate::VideoInputFrameArrived(IDeckLinkVideoInputFrame* videoFrame, IDeckLinkAudioInputPacket* audioFrame)
{
    IDeckLinkVideoFrame*                rightEyeFrame = NULL;
    IDeckLinkVideoFrame3DExtensions*    threeDExtensions = NULL;
    void*                                frameBytes;
    void*                                audioFrameBytes;
    int                                 dumpVidFile = -1;
    if (!videoFrame || !audioFrame)
    {
        printf("ERROR Video/Audio Mismatch\n");
    }

    // Handle Video Frame
    if (videoFrame)
    {
	if (videoFrame->GetFlags() & bmdFrameHasNoInputSource)
	{
		printf("Frame received (#%lu) - No input signal detected\n", g_video_frameCount);
	}
        // The BLT flashes Red in the top 100x100 every 4 seconds when audio goes, and Green (twice) in the next 100x100. 
        // As such, add the Lumas of the pixels together
        videoFrame->GetBytes(&frameBytes);
        char* fb1 = (char*)(frameBytes);

        // Should we be saving this?
        if (g_videoOutputFile != -1) {
//            printf("DEBUG: Dumping YUV to file\n");
            write(g_videoOutputFile, frameBytes, videoFrame->GetRowBytes() * videoFrame->GetHeight());
        }
        long squareLuma1 = 0;
        long squareLuma2 = 0;
        for (int line = 1; line <= 1080; line++) {
            // A "sample" is UYVY - making up 2 pixels, as it's 4:2:2 8 bit.
//            if (line > 650 && line < 690) { printf("LINE %d: ", line + 1); }

            long decode[32];
            for (int i = 0; i < 32; i++) {
                decode[i] = 0;
            }
            for (int sample = 0; sample < 960; sample++) {
                unsigned char u = *fb1;
                fb1++;
                unsigned char y1 = *fb1;
                fb1++;
                unsigned char v = *fb1;
                fb1++;
                unsigned char y2 = *fb1;
                fb1++;
                if (line < 100 && sample < 50) { 
                    squareLuma1 = squareLuma1 + y1 + y2; 
                } else if (line < 100 && sample < 100) { 
                    squareLuma2 = squareLuma2 + y1 + y2; 
                }
                // Line 660-680, pixsel 650-1270 (sample 235-635) has time-of-day encoded on the screen, surrounded by a sea of luma = 0xb4
                if (line > 659 && line < 675 && sample > 325 && sample <= 646) {
                    char c1 = '0';
                    char c2 = '0';
                    if (y1 > 128) { c1 = '1'; }
                    if (y2 > 128) { c2 = '1'; }

                    // Line 665 is a good line to detect on
                    // 20 pixels (10 samples) between each change
                    if (line == 665) {
                        for (int i = 0; i < 32; i++) {
                            int start = 328 + (i*10);
                            int end = 330 + (i*10);
                            if (sample >= start && sample <= end) {
                                decode[i] = decode[i] + y1 + y2;
                            }
                        }
                    }
                    if (line == 665 && g_video_frameCount % 25 == 0 ) {
//                        printf("Frame %ld, Sample: %d = %c%c\n", g_video_frameCount, sample, c1, c2);
                    //    if ((sample-325) % 10 == 0) { printf(" "); }
                    //    printf("%c%c",c1,c2);
                    }
//                    if ((sample % 1) == 0) { printf("%c",c1); }
 //                   if (sample == 485) { printf("\nB         "); }
                    //if ((sample % 32) == 0) { printf(" "); }
                }
//                if (line < 1500 && line % 20 == 0 && sample % 20 == 0) { printf("%04x", y1); }
            }
//            if (line > 650 && line < 690) { printf("\n"); }
//            if (line < 1500 && line % 20 == 0) { printf("\n"); }
            if (line == 665) { 
                int decodedTime = 0;
//                printf("TRACE: %ld decode (bin order ", g_video_frameCount);
//                for (int i = 31; i >= 0; i--) {
//                    printf("%d", decode[i] > 1000);
//                    if (i % 8 == 0) { printf(" "); }
//                }
//                printf("). Val");
                for (int i = 0; i < 32; i++) {
//                    printf("%d ", decode[i] > 1000);
                    if (decode[i] > 1000) {
                        int val = 1 << i;
//                        printf("(worth 2^%d = %d)", i, val);
                        decodedTime = decodedTime + val;
                    }
//                    printf(",");
                }
                time_t now;
                time(&now);
                if (g_lastRealTime != now) {
                    g_lastRealTime = now;
                    g_lastRealTimeFrames = 0;
                } else {
                    g_lastRealTimeFrames++;
                }
                if (g_lastDecodeTime != decodedTime) {
                    g_lastDecodeTime = decodedTime;
                    g_lastDecodeTimeFrames = 0;
                } else {
                    g_lastDecodeTimeFrames++;
                }
                long deltaSecs = g_lastRealTime - g_lastDecodeTime;
                long deltaFrames = g_lastRealTimeFrames - g_lastDecodeTimeFrames;
                long deltaF = (deltaSecs * 25) + deltaFrames;
                deltaF = deltaF - g_frameCalibration;
//                printf("DEBUG: Decoded Time == %lu.%d. Current time = %lu.%d. Delta Seconds = %ld, Delta Frames = %ld\n", g_lastDecodeTime, g_lastDecodeTimeFrames, g_lastRealTime, g_lastRealTimeFrames, deltaSecs, deltaFrames);
                if (g_lastDecodeTime < 1600000000 || g_lastDecodeTime > 2500000000) {
                    // Invalid time frame -- well outside the expected time boundaries
                } else if (g_currentLatency != deltaF) {
                    printf("INFO: Change in Latency by %ld frames, new latency %ld frames (%ld pre calibration)\n", deltaF - g_currentLatency, deltaF, g_frameCalibration + deltaF);
                    g_currentLatency = deltaF;
                }
            }
        }
//	int op = open("/tmp/test.uyvy", O_WRONLY|O_CREAT|O_TRUNC, 0664);
//	write(op, frameBytes, videoFrame->GetRowBytes() * videoFrame->GetHeight());
//	close(op);
        // If Silence, squareLuma1 will be 801900, if noisy it will be 1029600
        if (squareLuma1 > 700000 && squareLuma1 < 900000) {
            // Ch1 Should be silent
            if (g_lastSilenceEnd + 1 == g_video_frameCount) {
                // Still is silent
                g_lastSilenceEnd = g_video_frameCount;
                if (DEBUG > 7) printf("DEBUG: %lu Ch1 Should still be silent (%lu -> %lu, %lu)\n", g_video_frameCount, g_lastSilenceStart, g_lastSilenceEnd, g_lastSilenceEnd-g_lastSilenceStart);
            } else {
                long calcAudioSample = 1920 * g_video_frameCount;
                if (DEBUG > 7) printf("DEBUG: %lu Ch1 Should be a new silence at audio sample %lu\n", g_video_frameCount, calcAudioSample);

                g_lastSilenceStart = g_video_frameCount;
                g_lastSilenceEnd = g_video_frameCount;
                g_lastSilenceStartSample = calcAudioSample;
            }
        } else {
            // Ch1 Should be noisy
            if (DEBUG > 7) printf("DEBUG: %lu Ch1 Should be noisy as luma %lu\n", g_video_frameCount, squareLuma1);
        }
        
        g_video_frameCount++;
    }

    // Handle Audio Frame
    if (audioFrame)
    {

        audioFrame->GetBytes(&audioFrameBytes);
        // Should we be saving this?
        if (g_audioOutputFile != -1) {
//            printf("DEBUG: Dumping PCM to file\n");
            write(g_audioOutputFile, audioFrameBytes, audioFrame->GetSampleFrameCount() * g_config.m_audioChannels * (g_config.m_audioSampleDepth / 8));
        }
        short* afb1 = (short*)(audioFrameBytes);
        short* afb2 = (short*)(audioFrameBytes);
        
        short ch1 = *afb1;
        short ch2 = *afb2;

        for (int sample = 0; sample < 1920; sample++) {
            short val1 = *afb1;
            afb1++;
            short val2 = *afb1;
            afb1++;


            // Value is between 32k to 32k. Some decoders decode silence as zero, others vary. Appear can bobble along upto 100. Actual tone is going to the thousands, so assuming anything 0 +/- 300 should be silent -- if it's tone it won't stay there fore many samples, at 1khz it has a full sine wave in 48 samples and goes upto thousands
            if (val1 > -300 && val1 < 300) {
                // Silent, but could be transitory
                long fullSample = (1920*g_audio_frameCount)+sample;
                g_silentSamples++;
                if (g_silentSamples > 1000) {
                    // OK, this is a proper sample which started at fullSample - g_silentSamples
                    g_lastAudioSilenceStart = fullSample - g_silentSamples;
                    g_lastAudioSilenceEnd = fullSample;
                }
            } else {
                if (g_silentSamples > 1000) {
                    // End of silence
                    signed long audioDelay = g_lastAudioSilenceStart - g_lastSilenceStartSample;
                    if (DEBUG > 3) printf("DEBUG: Silence ended after %lu samples, val=%d sample %lu>%lu, should have started at %lu. Delay = %ld samples\n", g_silentSamples, val1, g_lastAudioSilenceStart, g_lastAudioSilenceEnd, g_lastSilenceStartSample, audioDelay);
                    time_t rawtime;
                    struct tm *info;
                    char buffer[80];
                    time( &rawtime );
                    info = localtime( &rawtime );
                    strftime(buffer,80,"%Y-%m-%d %H:%M:%S %Z", info);
//                    printf("%s: ", buffer);
                    long msDelay = round(audioDelay/48);
                    printf("INFO: %s> Current audio delay %ld samples (%ld ms). Current Calibrated Video Latency %d frames (%d). \n", buffer, audioDelay, msDelay, g_currentLatency, g_frameCalibration);
                    g_audioDelay = audioDelay;
                } else if (g_silentSamples > 5) {
                    signed long audioDelay = g_lastAudioSilenceStart - g_lastSilenceStartSample;
                    if (DEBUG > 3) printf("DEBUG: Silence ended too soon after %lu samples, val=%d sample %lu>%lu, should have started at %lu. Delay = %ld samples\n", g_silentSamples, val1, g_lastAudioSilenceStart, g_lastAudioSilenceEnd, g_lastSilenceStartSample, audioDelay);
                }
                g_silentSamples = 0;
            }
        }
//            printf("DEBUG Sound Frame silence= %ld\n", g_silentSamples);
        g_audio_frameCount++;

    }

// Capture near wrapround boundary 
/*        if (g_audioDelay > 1300 || g_audioDelay < -590) {
                char fname[128];
                snprintf(fname, sizeof(fname) * 32, "/var/www/html/work/wrapRound/%ld.yuv", g_video_frameCount);
                printf("Record in %s as audio delay %ld\n", fname, g_audioDelay);
		dumpVidFile = open(fname, O_WRONLY|O_CREAT|O_TRUNC, 0664);
		write(dumpVidFile, frameBytes, videoFrame->GetRowBytes() * videoFrame->GetHeight());
		close(dumpVidFile);
        }*/

        if (g_dumpEvery > 0 && g_video_frameCount % g_dumpEvery == 0) {
            // Dump raw video and audio fame every N frames
//		printf("Dump received (#%lu - dumping every %lu to %s) \n", g_video_frameCount, g_dumpEvery, g_config.m_videoFrameDump);
		dumpVidFile = open(g_config.m_videoFrameDump, O_WRONLY|O_CREAT|O_TRUNC, 0664);
		write(dumpVidFile, frameBytes, videoFrame->GetRowBytes() * videoFrame->GetHeight());
		close(dumpVidFile);
        }

    if (g_config.m_maxFrames > 0 && videoFrame && g_video_frameCount >= g_config.m_maxFrames)
    {
        g_do_exit = true;
        pthread_cond_signal(&g_sleepCond);
    }

    return S_OK;
}

HRESULT DeckLinkBLTDelegate::VideoInputFormatChanged(BMDVideoInputFormatChangedEvents events, IDeckLinkDisplayMode *mode, BMDDetectedVideoInputFormatFlags formatFlags)
{
    // This only gets called if bmdVideoInputEnableFormatDetection was set
    // when enabling video input
    HRESULT    result;
    char*    displayModeName = NULL;
    BMDPixelFormat    pixelFormat = m_pixelFormat;
    
    if (events & bmdVideoInputColorspaceChanged)
    {
        // Detected a change in colorspace, change pixel format to match detected format
        if (formatFlags & bmdDetectedVideoInputRGB444)
            pixelFormat = bmdFormat10BitRGB;
        else if (formatFlags & bmdDetectedVideoInputYCbCr422)
            pixelFormat = (g_config.m_pixelFormat == bmdFormat8BitYUV) ? bmdFormat8BitYUV : bmdFormat10BitYUV;
        else
            goto bail;
    }

    // Restart streams if either display mode or pixel format have changed
    if ((events & bmdVideoInputDisplayModeChanged) || (m_pixelFormat != pixelFormat))
    {
        mode->GetName((const char**)&displayModeName);
        printf("Video format changed to %s %s\n", displayModeName, formatFlags & bmdDetectedVideoInputRGB444 ? "RGB" : "YUV");

        if (displayModeName)
            free(displayModeName);

        if (g_deckLinkInput)
        {
            g_deckLinkInput->StopStreams();

            result = g_deckLinkInput->EnableVideoInput(mode->GetDisplayMode(), pixelFormat, g_config.m_inputFlags);
            if (result != S_OK)
            {
                fprintf(stderr, "Failed to switch video mode\n");
                goto bail;
            }

            g_deckLinkInput->StartStreams();
        }

        m_pixelFormat = pixelFormat;
    }

bail:
    return S_OK;
}

static void sigfunc(int signum)
{
    if (signum == SIGINT || signum == SIGTERM)
        g_do_exit = true;

    pthread_cond_signal(&g_sleepCond);
}

int main(int argc, char *argv[])
{
    HRESULT                            result;
    int                                exitStatus = 1;

    IDeckLinkIterator*                deckLinkIterator = NULL;
    IDeckLink*                        deckLink = NULL;

    IDeckLinkProfileAttributes*        deckLinkAttributes = NULL;
    bool                            formatDetectionSupported;
    int64_t                            duplexMode;

    IDeckLinkDisplayMode*            displayMode = NULL;
    char*                            displayModeName = NULL;
    bool                            supported;

    DeckLinkBLTDelegate*        delegate = NULL;

    pthread_mutex_init(&g_sleepMutex, NULL);
    pthread_cond_init(&g_sleepCond, NULL);

    signal(SIGINT, sigfunc);
    signal(SIGTERM, sigfunc);
    signal(SIGHUP, sigfunc);

    // Process the command line arguments
    if (!g_config.ParseArguments(argc, argv))
    {
        g_config.DisplayUsage(exitStatus);
        goto bail;
    }

    // Get the DeckLink device
    deckLink = g_config.GetSelectedDeckLink();
    if (deckLink == NULL)
    {
        fprintf(stderr, "Unable to get DeckLink device %u\n", g_config.m_deckLinkIndex);
        goto bail;
    }

    // Check the Genlock status
    if (g_config.m_doGenlock == 1) {
        result = deckLink->QueryInterface(IID_IDeckLinkOutput, (void**)&g_deckLinkOutput);
        if (result == S_OK)
        {
            BMDReferenceStatus reference_status;
            if (g_deckLinkOutput->GetReferenceStatus(&reference_status) != S_OK)
            {
                printf("ERROR Can't read reference status\n");
                exitStatus = 3;
                goto bail;
            }
            if (reference_status == 0) {
                printf("Reference: NONE\n");
                exitStatus = 2;
            } else if (reference_status & bmdReferenceNotSupportedByHardware) {
                printf("Reference: Not Supported\n");
                exitStatus = 3;
            } else if (reference_status & bmdReferenceLocked) {
                printf("Reference: Locked\n");
                exitStatus = 0;
            } else {
                printf("Reference: Unknown (%d)\n", reference_status);
                exitStatus = 3;
            }
            goto bail;
        }
        printf("ERROR getting Decklink Output\n");
        exitStatus = 3;
        goto bail;
    }

    result = deckLink->QueryInterface(IID_IDeckLinkProfileAttributes, (void**)&deckLinkAttributes);
    if (result != S_OK)
    {
        fprintf(stderr, "Unable to get DeckLink attributes interface\n");
        goto bail;
    }

    // Check the DeckLink device is active
    result = deckLinkAttributes->GetInt(BMDDeckLinkDuplex, &duplexMode);
    if ((result != S_OK) || (duplexMode == bmdDuplexInactive))
    {
        fprintf(stderr, "The selected DeckLink device is inactive\n");
        goto bail;
    }

    // Get the input (capture) interface of the DeckLink device
    result = deckLink->QueryInterface(IID_IDeckLinkInput, (void**)&g_deckLinkInput);
    if (result != S_OK)
    {
        fprintf(stderr, "The selected device does not have an input interface\n");
        goto bail;
    }

    // Get the display mode
    if (g_config.m_displayModeIndex == -1)
    {
        // Check the card supports format detection
        result = deckLinkAttributes->GetFlag(BMDDeckLinkSupportsInputFormatDetection, &formatDetectionSupported);
        if (result != S_OK || !formatDetectionSupported)
        {
            fprintf(stderr, "Format detection is not supported on this device\n");
            goto bail;
        }

        g_config.m_inputFlags |= bmdVideoInputEnableFormatDetection;
    }

    displayMode = g_config.GetSelectedDeckLinkDisplayMode(deckLink);

    if (displayMode == NULL)
    {
        fprintf(stderr, "Unable to get display mode %d\n", g_config.m_displayModeIndex);
        goto bail;
    }

    // Get display mode name
    result = displayMode->GetName((const char**)&displayModeName);
    if (result != S_OK)
    {
        displayModeName = (char *)malloc(32);
        snprintf(displayModeName, 32, "[index %d]", g_config.m_displayModeIndex);
    }

    // Check display mode is supported with given options
    result = g_deckLinkInput->DoesSupportVideoMode(bmdVideoConnectionUnspecified, displayMode->GetDisplayMode(), g_config.m_pixelFormat, bmdNoVideoInputConversion, bmdSupportedVideoModeDefault, NULL, &supported);
    if (result != S_OK)
        goto bail;

    if (! supported)
    {
        fprintf(stderr, "The display mode %s is not supported with the selected pixel format\n", displayModeName);
        goto bail;
    }

    if (g_config.m_inputFlags & bmdVideoInputDualStream3D)
    {
        if (!(displayMode->GetFlags() & bmdDisplayModeSupports3D))
        {
            fprintf(stderr, "The display mode %s is not supported with 3D\n", displayModeName);
            goto bail;
        }
    }

    // Set latency calibration
    g_frameCalibration = g_config.m_latencyCalibrate;

    // Set dump every
    g_dumpEvery = g_config.m_dumpEvery;
    
    // Print the selected configuration
    g_config.DisplayConfiguration();

    // Configure the capture callback
    delegate = new DeckLinkBLTDelegate();
    g_deckLinkInput->SetCallback(delegate);

    // Open output files
    if (g_config.m_videoOutputFile != NULL)
    {
        g_videoOutputFile = open(g_config.m_videoOutputFile, O_WRONLY|O_CREAT|O_TRUNC, 0664);
        if (g_videoOutputFile < 0)
        {
            fprintf(stderr, "Could not open video output file \"%s\"\n", g_config.m_videoOutputFile);
            goto bail;
        }
    }

    if (g_config.m_audioOutputFile != NULL)
    {
        g_audioOutputFile = open(g_config.m_audioOutputFile, O_WRONLY|O_CREAT|O_TRUNC, 0664);
        if (g_audioOutputFile < 0)
        {
            fprintf(stderr, "Could not open audio output file \"%s\"\n", g_config.m_audioOutputFile);
            goto bail;
        }
    }

    // Block main thread until signal occurs
    while (!g_do_exit)
    {
        // Start capturing
        result = g_deckLinkInput->EnableVideoInput(displayMode->GetDisplayMode(), g_config.m_pixelFormat, g_config.m_inputFlags);
        if (result != S_OK)
        {
            fprintf(stderr, "Failed to enable video input. Is another application using the card?\n");
            goto bail;
        }

        result = g_deckLinkInput->EnableAudioInput(bmdAudioSampleRate48kHz, g_config.m_audioSampleDepth, g_config.m_audioChannels);
        if (result != S_OK)
            goto bail;

        result = g_deckLinkInput->StartStreams();
        if (result != S_OK)
            goto bail;

        // All Okay.
        exitStatus = 0;

        pthread_mutex_lock(&g_sleepMutex);
        pthread_cond_wait(&g_sleepCond, &g_sleepMutex);
        pthread_mutex_unlock(&g_sleepMutex);

        fprintf(stderr, "Stopping Capture\n");
        g_deckLinkInput->StopStreams();
        g_deckLinkInput->DisableAudioInput();
        g_deckLinkInput->DisableVideoInput();
    }

bail:
    if (g_videoOutputFile != 0)
        close(g_videoOutputFile);

    if (g_audioOutputFile != 0)
        close(g_audioOutputFile);

    if (displayModeName != NULL)
        free(displayModeName);

    if (displayMode != NULL)
        displayMode->Release();

    if (delegate != NULL)
        delegate->Release();

    if (g_deckLinkInput != NULL)
    {
        g_deckLinkInput->Release();
        g_deckLinkInput = NULL;
    }

    if (deckLinkAttributes != NULL)
        deckLinkAttributes->Release();

    if (deckLink != NULL)
        deckLink->Release();

    if (deckLinkIterator != NULL)
        deckLinkIterator->Release();

    return exitStatus;
}
